// code by mg
package ch.ethz.idsc.demo.mg.slam;

import java.awt.Graphics2D;
import java.awt.image.BufferedImage;

import ch.ethz.idsc.demo.mg.pipeline.PipelineConfig;
import ch.ethz.idsc.owl.gui.RenderInterface;
import ch.ethz.idsc.owl.gui.win.GeometricLayer;

// gives an image of the maps generated by the SLAM algorithm
// TODO save method
// TODO draw mapArray onto image of matching dimensions
public class SlamMapFrame implements RenderInterface {
  private final BufferedImage bufferedImage;
  private final Graphics2D graphics;
  // visualization stuff
  private final double scale;
  private final double height;
  // from the SLAM algorithm
  private MapProvider[] maps;

  SlamMapFrame(PipelineConfig pipelineConfig) {
    bufferedImage = new BufferedImage(400,200,BufferedImage.TYPE_BYTE_INDEXED);
    graphics = bufferedImage.createGraphics();
    scale = 2;
    height = 200;
  }

  public void setMaps(MapProvider[] maps) {
    this.maps = maps;
  }

  @Override
  public void render(GeometricLayer geometricLayer, Graphics2D graphics) {
    // code below from BayesianOccupancyGrid, might implement similar solution
    // Tensor model2pixel = geometricLayer.getMatrix();
    // Tensor translate = IdentityMatrix.of(3);
    // translate.set(lbounds.get(0).multiply(cellDimInv), 0, 2);
    // translate.set(lbounds.get(1).multiply(cellDimInv), 1, 2);
    // Tensor matrix = model2pixel.dot(scaling).dot(translate);
    // graphics.drawImage(obstacleImage, AffineTransforms.toAffineTransform(matrix), null);
  }
}
