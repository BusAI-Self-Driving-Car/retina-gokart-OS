// code by mg
package ch.ethz.idsc.demo.mg.slam;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.geom.AffineTransform;
import java.awt.geom.Ellipse2D;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.awt.image.DataBufferByte;

import ch.ethz.idsc.demo.mg.pipeline.PipelineConfig;
import ch.ethz.idsc.owl.gui.RenderInterface;
import ch.ethz.idsc.owl.gui.win.GeometricLayer;
import ch.ethz.idsc.tensor.Tensor;

// gives an image of the maps generated by the SLAM algorithm
// TODO draw mapArray onto image of matching dimensions
public class SlamMapFrame implements RenderInterface {
  private static final byte CLEAR_BYTE = (byte) 255; // white
  private final BufferedImage bufferedImage;
  private final Graphics2D graphics;
  private final byte[] bytes;
  // visualization stuff
  private final int frameWidth;
  private final int frameHeight;
  private final int numberOfCells;
  private final double cornerX;
  private final double cornerY;
  private final double cellDim;
  // from the SLAM algorithm
  private double[] mapArray;
  private double maxValue;

  SlamMapFrame(PipelineConfig pipelineConfig) {
    frameWidth = pipelineConfig.dimX.divide(pipelineConfig.cellDim).number().intValue();
    frameHeight = pipelineConfig.dimY.divide(pipelineConfig.cellDim).number().intValue();
    numberOfCells = frameWidth * frameHeight;
    cornerX = pipelineConfig.corner.Get(0).number().doubleValue();
    cornerY = pipelineConfig.corner.Get(1).number().doubleValue();
    cellDim = pipelineConfig.cellDim.number().doubleValue();
    mapArray = new double[numberOfCells];
    bufferedImage = new BufferedImage(frameWidth, frameHeight, BufferedImage.TYPE_BYTE_GRAY);
    graphics = bufferedImage.createGraphics();
    DataBufferByte dataBufferByte = (DataBufferByte) bufferedImage.getRaster().getDataBuffer();
    bytes = dataBufferByte.getData();
  }

  public void setMap(MapProvider map) {
    // safety check
    if (map.getNumberOfCells() != numberOfCells)
      System.out.println("Fatal: something went wrong!");
    else {
      mapArray = map.getMapArray();
      maxValue = map.getMaxValue();
      constructFrame();
    }
  }

  // draws the frame according to the mapArray values
  private void constructFrame() {
    // values are normalized by maxValue
    for (int i = 0; i < bytes.length; i++) {
      bytes[i] = (byte) (255 * (1 - mapArray[i] / maxValue));
    }
  }

  public void addGokartPose(Tensor pose) {
    double posX = pose.Get(0).number().doubleValue();
    double posY = pose.Get(1).number().doubleValue();
    double rotAngle = pose.Get(2).number().doubleValue();
    // get pixelPos
    int pixelPoseX = (int) ((posX - cornerX) / cellDim);
    int pixelPoseY = (int) ((posY - cornerY) / cellDim);
    // draw ellipse at go kart position
    Ellipse2D ellipse = new Ellipse2D.Float(pixelPoseX - 15, pixelPoseY - 8, 30, 16);
    AffineTransform old = graphics.getTransform();
    graphics.rotate(rotAngle, pixelPoseX, pixelPoseY);
    graphics.setColor(Color.BLACK);
    graphics.draw(ellipse);
    graphics.setTransform(old);
  }

  // NOTE: we rotate only for visualization purposes.
  public BufferedImage getFrame() {
    return flipVertical(bufferedImage);
  }

  @Override
  public void render(GeometricLayer geometricLayer, Graphics2D graphics) {
    // code below from BayesianOccupancyGrid, might implement similar solution
    // Tensor model2pixel = geometricLayer.getMatrix();
    // Tensor translate = IdentityMatrix.of(3);
    // translate.set(lbounds.get(0).multiply(cellDimInv), 0, 2);
    // translate.set(lbounds.get(1).multiply(cellDimInv), 1, 2);
    // Tensor matrix = model2pixel.dot(scaling).dot(translate);
    // graphics.drawImage(obstacleImage, AffineTransforms.toAffineTransform(matrix), null);
  }

  // TODO move to static class
  private BufferedImage flipVertical(BufferedImage bufferedImage) {
    AffineTransform affineTransform = AffineTransform.getScaleInstance(1, -1);
    affineTransform.translate(0, -bufferedImage.getHeight());
    AffineTransformOp affineTransformOp = new AffineTransformOp(affineTransform, AffineTransformOp.TYPE_NEAREST_NEIGHBOR);
    return affineTransformOp.filter(bufferedImage, null);
  }
}
